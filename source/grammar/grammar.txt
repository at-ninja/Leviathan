program: stmt* ENDMARKER

stmt: simple_stmt | compound_stmt | block
block: '{' stmt* '}' [';']

simple_stmt: small_stmt [';']
small_stmt: (expr_stmt | flow_stmt | import_stmt)
expr_stmt: test (augassign test | ('=' test)*)
augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '//=')
flow_stmt: break_stmt | continue_stmt | return_stmt | throw_stmt
break_stmt: 'break'
continue_stmt: 'continue'
return_stmt: 'return' [testlist]
throw_stmt: 'throw' [test ['from' test]]
import_stmt: 'import' test

compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef
if_stmt: 'if' test (':' stmt | block) ('elif' test (':' stmt | block))* ['else' (':' stmt | block)]
while_stmt: 'while' test (':' stmt | block) ['else' (':' stmt | block)]
for_stmt: 'for' atom_expr 'in' test (':' stmt | block)
try_stmt: 'try' (':' stmt | block) (except_clause (':' stmt | block))+
except_clause: 'except' [test ['as' NAME]]


atom: NAME | NUMBER | STRING+ | 'none' | 'true' | 'false' | '[' [arglist] ']'
atom_expr: atom trailer*
trailer: '(' [arglist] ')' | '[' [test] ']' | '.' NAME
arglist: argument (',' argument)* [',']
argument: test
test: or_test | lambda_def
or_test: and_test ('or' and_test)*
and_test: not_test ('and' not_test)*
not_test: 'not' not_test | comparison
comparison: expr (comp_op expr)*
comp_op: '<' | '>' | '==' | '>=' | '<=' | '<>' | 'in' | 'not' 'in' | 'is' | 'is' 'not'
expr: term (('+'|'-') term)*
term: factor (('*' | '/' | '%' | '//') factor)*
factor: ('+'|'-'|'~') factor | power
power: atom_expr ['**' factor]

lambda_def: 'lambda' parameters (':' stmt | block)
funcdef: 'function' NAME parameters (':' stmt | block)
classdef: 'class' NAME parameters (':' stmt | block)
//classdef: 'class' NAME (':' stmt | block)
parameters: '(' [paramlist] ')'
paramlist: NAME (',' NAME)* [',']